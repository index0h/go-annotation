package annotation

import (
	"encoding/json"
	"reflect"
	"regexp"
)

// Default prefix for file rendering.
// Annotation FileIsGenerated is used internally to check, that file could be overwritten.
const Header = "" +
	"// Generated by github.com/index0h/go-annotation\n" +
	"// DO NOT EDIT\n" +
	"// @FileIsGenerated(true)\n"

type FileIsGeneratedAnnotation bool

var identRegexp = regexp.MustCompile(`^[\p{L}_][\p{L}\d_]*$`)

func cloneAnnotations(annotations []interface{}) []interface{} {
	if annotations == nil {
		return nil
	}

	result := make([]interface{}, len(annotations))

	for i, annotation := range annotations {
		data, err := json.Marshal(annotation)

		if err != nil {
			panic(err)
		}

		annotationCopy := reflect.New(reflect.TypeOf(annotation)).Interface()

		if len(data) > 0 {
			if err = json.Unmarshal(data, &annotationCopy); err != nil {
				panic(err)
			}
		}

		result[i] = reflect.ValueOf(annotationCopy).Elem().Interface()
	}

	return result
}

func uniqImports(all []*Import) []*Import {
	if all == nil {
		return nil
	}

	result := []*Import{}

	for _, element := range all {
		isUniq := true

		for _, resultElement := range result {
			if resultElement == element || (resultElement.Alias == element.Alias &&
				resultElement.Namespace == element.Namespace &&
				resultElement.Comment == element.Comment) {
				isUniq = false

				break
			}
		}

		if isUniq {
			result = append(result, element)
		}
	}

	return result
}

func fetchImportsFromContent(content string, file *File) []*Import {
	if content == "" {
		return nil
	}

	aliases := ""

	for _, importGroup := range file.ImportGroups {
		for _, element := range importGroup.Imports {
			if aliases != "" {
				aliases += "|"
			}

			aliases += element.RealAlias()
		}
	}

	if aliases == "" {
		return nil
	}

	result := []*Import{}

	matches := regexp.
		MustCompile("([ \\t\\n&;,!~^=+\\-*/()\\[\\]{}]|^)("+aliases+")([ \\t]*\\.)").
		FindAllStringSubmatch(content, -1)

	for _, match := range matches {
		alias := match[2]

		for _, importGroup := range file.ImportGroups {
			for _, element := range importGroup.Imports {
				if alias == element.RealAlias() {
					result = append(result, element)
				}
			}
		}
	}

	return result
}

func renameImportsInContent(content string, oldAlias string, newAlias string) string {
	if content == "" {
		return ""
	}

	return regexp.
		MustCompile("([ \\t\\n&;,!~^=+\\-*/()\\[\\]{}]|^)"+oldAlias+"([ \\t]*\\.)").
		ReplaceAllString(content, "${1}"+newAlias+"${2}")
}
