package annotation

import (
	"go/format"
	"strings"
)

const Header = "" +
	"// Generated by github.com/index0h/go-annotation\n" +
	"// DO NOT EDIT\n" +
	"// @FileIsGeneratedAnnotation(true)\n"

type Renderer struct {
	specRenderer SpecRenderer
}

func NewRenderer() *Renderer {
	return &Renderer{}
}

func (r *Renderer) Process(storage *Storage) {
	for _, namespace := range storage.Namespaces {
		for _, file := range namespace.Files {
			if file.Content != "" {
				continue
			}

			content := Header + r.renderComment(file.Comment) +
				"package " + file.PackageName + "\n\n"

			for _, element := range file.ImportGroups {
				content += r.renderImportGroup(element)
			}

			for _, element := range file.ConstGroups {
				content += r.renderConstGroup(element)
			}

			for _, element := range file.VarGroups {
				content += r.renderVarGroup(element)
			}

			for _, element := range file.TypeGroups {
				content += r.renderTypeGroup(element)
			}

			for _, element := range file.Funcs {
				content += r.renderFunc(element)
			}

			formattedContent, err := format.Source([]byte(content))

			if err != nil {
				panic(err)
			}

			file.Content = string(formattedContent)

			if file.Annotations == nil {
				file.Annotations = []interface{}{FileIsGeneratedAnnotation(true)}
			} else {
				file.Annotations = append(file.Annotations, FileIsGeneratedAnnotation(true))
			}
		}
	}
}

func (r *Renderer) renderComment(comment string) string {
	if comment == "" {
		return ""
	}

	return "// " + strings.Join(strings.Split(strings.TrimSpace(comment), "\n"), "\n// ") + "\n"
}

func (r *Renderer) renderImportGroup(entity *ImportGroup) string {
	if len(entity.Imports) == 1 && entity.Imports[0].Comment == "" {
		return r.renderComment(entity.Comment) +
			"import " + entity.Imports[0].Alias + " \"" + entity.Imports[0].Namespace + "\"\n\n"
	}

	result := r.renderComment(entity.Comment) +
		"import (\n"

	for _, element := range entity.Imports {
		result += r.renderComment(element.Comment) + element.Alias + " \"" + element.Namespace + "\"\n"
	}

	return result + ")\n\n"
}

func (r *Renderer) renderConstGroup(entity *ConstGroup) string {
	if len(entity.Consts) == 1 && entity.Consts[0].Comment == "" {
		return r.renderComment(entity.Comment) +
			"const " + entity.Consts[0].Name + " " + r.specRenderer.RenderSpec(entity.Consts[0].Spec) +
			" = " + entity.Consts[0].Value + "\n\n"
	}

	result := r.renderComment(entity.Comment) + "const (\n"

	for _, element := range entity.Consts {
		result += r.renderComment(element.Comment) +
			element.Name + " " + r.specRenderer.RenderSpec(element.Spec)

		if element.Value != "" {
			result += " = " + element.Value
		}

		result += "\n"
	}

	return result + ")\n\n"
}

func (r *Renderer) renderVarGroup(entity *VarGroup) string {
	if len(entity.Vars) == 1 && entity.Vars[0].Comment == "" {
		result := r.renderComment(entity.Comment) +
			"var " + entity.Vars[0].Name + " " + r.specRenderer.RenderSpec(entity.Vars[0].Spec)

		if entity.Vars[0].Value != "" {
			return result + " = " + entity.Vars[0].Value + "\n\n"
		} else {
			return result + "\n\n"
		}
	}

	result := r.renderComment(entity.Comment) + "var (\n"

	for _, element := range entity.Vars {
		result += r.renderComment(element.Comment) +
			element.Name + " " + r.specRenderer.RenderSpec(element.Spec)

		if element.Value != "" {
			result += " = " + element.Value
		}

		result += "\n"
	}

	return result + ")\n\n"
}

func (r *Renderer) renderTypeGroup(entity *TypeGroup) string {
	if len(entity.Types) == 1 && entity.Types[0].Comment == "" {
		return r.renderComment(entity.Comment) +
			"type " + entity.Types[0].Name + " " + r.specRenderer.RenderSpec(entity.Types[0].Spec) + "\n\n"
	}

	result := r.renderComment(entity.Comment) + "type (\n"

	for _, element := range entity.Types {
		result += r.renderComment(element.Comment) +
			element.Name + " " + r.specRenderer.RenderSpec(element.Spec) + "\n"
	}

	return result + ")\n\n"
}

func (r *Renderer) renderFunc(element *Func) string {
	result := r.renderComment(element.Comment) + "func "

	if element.Related != nil {
		if element.Related.Comment != "" {
			result += "(\n" + r.renderComment(element.Related.Comment)
		} else {
			result += "("
		}

		result += element.Related.Name + " " + r.specRenderer.RenderSpec(element.Related.Spec) + ") "
	}

	return result + " " + element.Name + r.specRenderer.RenderSpec(element.Spec) + "{\n" + element.Content + "\n}\n\n"
}
